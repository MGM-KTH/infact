%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt,numbers=endperiod]{scrartcl} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
%\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line today return to the LaTeX default
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages

\usepackage[utf8]{inputenc} % Needed to support swedish "åäö" chars
\usepackage{titling} % Used to re-style maketitle

\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\normalfont} % Make all sections the default font

% Local packages:
\usepackage{enumerate}
\usepackage[usenames,dvipsnames]{color}
\usepackage{tabularx}
\usepackage{fancyvrb}
\DefineShortVerb{\|}
\usepackage{hyperref}
\usepackage{url}
\usepackage[parfill]{parskip}   % Sets newlines between paragraphs
\usepackage{algorithm2e} % Used for Pseudocode
\providecommand{\abs}[1]{\lvert#1\rvert} % \abs{x+y} produces |x+y|



\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

% Header with additional info
% \fancyhead[L]{\small{Gustaf Lindstedt - \href{mailto:glindste@kth.se}{\color{RoyalBlue}\nolinkurl{glindste@kth.se}} - 910301\\Martin Runelöv - \href{mailto:mrunelov@kth.se}{\color{RoyalBlue}\nolinkurl{mrunelov@kth.se}} - 900330-5738}}
% Simple header
\fancyhead[L]{\small{Gustaf Lindstedt\\Martin Runelöv}} % 


\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{23.0pt} % Customize the height of the header
\fancyhfoffset[L]{10mm}% slightly less than 0.25in

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text


\posttitle{\par\end{center}} % Remove space between author and title
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{	
\huge Project 1 - Factoring \\ % The assignment title
\vspace{10pt}
\normalfont \normalsize 
\textsc{DD2440 - Advanced algorithms } \\ [25pt] % 
}

\author{\vspace{-20pt} Gustaf Lindstedt - \nolinkurl{glindste@kth.se} - 910301-2135\\\\\\Martin Runelöv - \nolinkurl{mrunelov@kth.se} - 900330-5738}

\date{\vspace{8pt}\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

%-------------------------------------------------------------------------------
%	SECTION 1
%-------------------------------------------------------------------------------

\section{Introduction}

\subsection{Problem}
A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.
The prime factorization of a positive integer is a list of primes that divides the integer, and their multiplicities.
The problem of finding these prime factors is called integer factorization.

The fundamental theorem of arithmetic states that every positive integer (> 1) is either prime or a unique product of prime numbers.
In other words, all natural numbers can be factorized.

The purpose of this project is to study and implement factorization algorithms in order to successfully factorize a set of composite numbers, most of which are non-trivial.



%-------------------------------------------------------------------------------
%	SECTION 2
%-------------------------------------------------------------------------------
\section{Method}
\subsection{Algorithms}
\subsubsection{Pollard's rho algorithm}
The first algorithm used was Pollard's rho algorithm\cite{pollard}.
It is a probabilistic algorithm that tries to find one factor of a composite number.
The algorithm is then executed multiple times until the number is completely factorized, or until it fails.

The idea behind the algorithm is that we can improve the odds of guessing a factor of a composite number $N$.
The phenomenon is known as the \emph{birthday problem} or \emph{birthday paradox}\cite{birthday}.
% Borde ha nån sorts liknelse som gör det tydligt hur det faktiskt relaterar till birthday om vi ska nämna det

In Pollard's rho algorithm the odds are improved as follows:

Suppose that we want to guess a factor $d$ of $N$.
We know that at least one factor is less than or equal to $\sqrt{N}$, so we can safely say that we have a $\frac{1}{\sqrt{N}}$ chance of guessing $d$.
If we instead pick two random numbers $x_i$ and $x_j$ in a sequence $x_1 .. x_k$ and calculate their difference, what are the odds of that difference being a factor of $N$?
If we choose values $x_i$ and $x_j$ such that the difference is never greater than $\sqrt{N}$, there are about $2(\sqrt{N})$ (actually $2(\sqrt{N}-d)$) different combinations of $x_i$ and $x_j$ that has the property $x_i - x_j = d$.
Subsequently there are $N$ possible values of $x_i$ and $x_j$.
The new probability of guessing $d$ is therefore approximately $\frac{2\sqrt{N}}{N} = \frac{2}{\sqrt{N}}$.
The probability of guessing $d$ is doubled.\cite{colorado}

We extend this idea by picking $k$ random numbers and check if the difference of any two of these numbers equal a factor of $N$.
The birthday paradox states that the probability of guessing a factor increases rapidly with $k$.
For example, the probability of any two people sharing a birthday in a room of 23 people is 50\%, assuming all birthdays are equally probable.
For 57 people, the probability is 99\%.

This is exactly what Pollard's rho algorithm makes use of by using a pseudo-random generator to generate numbers.

It uses two increasing values modulo $N$ to generate numbers with which to find the greatest common divisor for $N$.
The method uses the sequence $x_{i+1} = x^2 + 1 \bmod N$, where $i > 0$, to generate two values, $x_i$ and $x_{2i}$.
The algorithm then runs $gcd(\abs{x_{2i}-x_i})$.
If the result is greater than 1, the result is a non-trivial factor of $N$.
See pseudocode below.
%The reason for calculating the $i^{\text{\tiny{ith}}}$ and $2i^{\text{\tiny{ith}}}$ numbers is that ... Pollard said so. (har källa på det iofs...inte från Pollard själv iofs...)


Note that the pseudocode does not take into account the case where $d = N$.
If $d = N$, the algorithm has failed to find a factor.
The pseudo-random generator $f(x)$ is defined as: $x^2+C\, (mod\, N)$, where $C$ is an arbitrary constant which maintains the property\\ $x = y\, (mod\; p) \rightarrow f(x) = f(y)\,(mod\; p)$.\\ Pollard suggested $C = 1$, but there are many other polynomials that satisfy this requirement.\\ % Source? Än så länge wikipedia.


\begin{algorithm}[H]
 \SetAlgoLined % For previous releases [?]
 \textbf{Input:} {A composite number N}\\
 \textbf{Output:} {A non-trivial factor of N}\\
 let $x_0 \in_U \mathbb{Z}_N$\\
 $x := x_0$\;
 $y := x_0$\;
 \While{True}{
  $x := f(x)$\;
  $y := f(f(y))$\;
  $d := gcd( \abs{y-x}, N)$\;
  \If{$d > 1$}{
   return d\;
   }
 }
 \caption{Pollard's rho algorithm \cite{algnotes}}
\end{algorithm}
\hspace{0pt}\\\\


\subsubsection{Brent's Factorization Method}
% Förslag till ändring från nedanstående utkommenterade mening
Brent's method is built upon Pollard's rho algorithm.
It improves detection of periodicity in the pseudo-random sequence. \cite{brent}
%Some improvements were made by Richard Brent and Pollard.

This improvement mostly center around the fact that multiplying consecutive differences $x_{2i}-x_i$ preserves any divisor $d$ of $N$.
% Nånting om cykler
Therefore the computation of a greatest common divisor, which is expensive, can be performed a lot less.
This can however introduce problems if the product $q$ grows to $q = 0 \bmod N$, since we then get the result $d=N$.
However, this can be countered by not multiplying too many times, and by backtracking to the last $x_i$ and $x_{2i}$ and performing the regular Pollard's rho procedure if $d=N$.

Pseudocode for Brent's factorization method: \\

\begin{algorithm}[H]
 \SetAlgoLined % For previous releases [?]
 \textbf{Input:} {A composite number N}\\
 \textbf{Output:} {A non-trivial factor of N}\\
 $y := 2$\tcp*[l]{arbitrary start value}
 $r := 1$\;
 $q := 1$\;
 \Repeat{d > 1} {
   $x := y$\;
   \For{i := 1 to r}{
   $y := f(y)$\;
   }
   $k := 0$\;
   \Repeat{ $k \geq r$ or d > 1 }{
      $ys := y$\;
      \For(\tcp*[h]{accumulate differences}){i := 1 to min(m, r--k)}{
        $y := f(y)$\;
        $q := q\times\abs{x-y} \bmod N$
      }
      $d := gcd(q, N)$\;
      $k := k + m$\;
   }
   $r := r\times2$\;
 }
 \If(\tcp*[h]{try previous y}){G = N}{
    \Repeat{G > 1}{
      $ys := f(ys)$\;
      $d = gcd(\abs{x-ys},N)$\;
    }
 }
 \caption{Brent's factorization method \cite{brent}}
\end{algorithm}
\hspace{0pt}\\\\



\subsubsection{Fermat's Factorization Method}
Fermat's factorization method\cite{fermat} is based on the ability to represent an odd integer as the difference of two squares $N = a^2 - b^2$.
Different values of $a$ are tried, searching for an $a$ such that the expression $a^2 - N$, which is equivalent to $b^2$, produces a square.

\begin{algorithm}[H]
 \SetAlgoLined % For previous releases [?]
 \textbf{Input:} {A composite number N}\\
 \textbf{Output:} {A non-trivial factor of N}\\
 $a := ceil(sqrt(N))$\\
 $b2 := a*a - N$\\
 \While{b2 isn't a square}{
  $a := a+1$\;
  $b2 := a*a - N$\;
  }
  return $a-sqrt(b2)$\;
  \hspace{0pt}\\
  \caption{Fermat's factorization method \cite{fermat}}
\end{algorithm}

\subsubsection{Quadratic Sieve}
The quadratic sieve \cite{qsieve} is the fastest known factorization algorithm for numbers below about 100 decimal digits\cite{qsieve2}. 

% oklart om detta är noggrant nog. tänkte börja enkelt innan vi bestämmer oss för att gå djupt.
Just as Fermat's factorization method it searches for a congruence of squares modulo $N$. However, instead of the naive approach used by Fermat it uses linear algebra to find squares. The basic idea is to study the parity of each of the multiplicities of the prime factors of a number. For example, the number $144$ is a square since its prime factorization is $2^{4}3^2$ and both exponents $4$ and $2$ are even ($144 = 2^2 3^1\times2^2 3^1$).

% Övriga steg påminner om/är exakt som Fermat's? 

\subsection{Implementation}
Due to apparent popularity and perceived efficiency of the algorithm, the Pollard's Rho algorithm was chosen for the first implementation.
A static list of the first 10 000 primes was used to weed out trivial primes with trial division, since a composite often contain low primes.
When using PR only the first 500-2000 primes were used for the trial division.

In practice, the $while$-loop runs a fixed number of times since the program has a deadline to keep.
Another paper that describes several algorithms, including the Brent improvements (not the version we're using, this one gave $\sim$57 in Kattis.
A lot simpler though.)\cite{otherpaper} % Vad säger vi med den här meningen???

The factorization program was written in |C| and uses the library GMP\cite{gmp} to represent large numbers and perform functions such as primality testing and GCD.

Before each iteration of PR, primality testing is performed.
This is done using GMP's built-in function |mpz_probab_prime| which uses trial division and Miller-Rabin probabilistic primality tests internally.\cite{probabprime}

%Massa om hur vi implementerade koden

%-------------------------------------------------------------------------------
%   SECTION 3
%-------------------------------------------------------------------------------

\section{Results}

The table below shows you how many of the 100 KATTIS numbers that the different algorithms were able to factorize.

    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Algorithm} & \textbf{Factorized numbers} \\ \hline
    Trial division & 11 \\ \hline
    Trial division + primality test & 19 \\ \hline
    Fermat's & 29 \\ \hline
    Pollard's rho & 73 \\ \hline
    Brent's & 86* \\ \hline
    \end{tabular}
    \hspace{10pt}

    \footnotesize{*submission ID for the best submission: \href{https://kth.kattis.scrool.se/submission?id=454917}{453799}
    \normalsize

Note that the three factorization algorithms Fermat's, Pollard's and Brent's all use trial division and primality testing.

Pollard's rho algorithm got results between 57 and 73, and Brent's factorization method got results between 73 and 86.
In order to avoid going over the time limit of 15 seconds we had to skip numbers above a certain size.
Pollard's rho got its best results when we skipped numbers greater than 86 bits.
Since Brent's method is faster, we were able to include numbers up to 95 bits without reaching the time limit.

We also had to set a limit on the number of iterations.
This was done using trial-and-error since the number of iterations necessary depends on the numbers to be factored.
These iteration limits turned out to be slightly arbitrary once above a certain threshold, which seems to indicate that most if not all numbers were successfully factored.
However, one slight modification was made in Brent's method.
The number of iterations performed for numbers greater than 90 bits in size were set a lot lower than the default limit. This was necessary in order to finish on time. 
This can be explained by the fact that we fail to factorize many of these bigger numbers, 
and even if we succeed they could require many iterations.

After reaching 86 points we noted that the backtrack loop used by Brent's method, when the first loop results in $d = N,$ never found any factors. With this loop removed we achieved the same result faster.

% Removing the backup-iteration when d == N in Brent only improved time. 
% It never gave any extra factors.
% + Something about default iterations maxing out at 30k instead of about 100k for most numbers.
% And maybe mention starting values, "m", "C" etc.


\subsection{Discussion}
Were the results expected? Why?\\
Given more time, what could have been improved?\\
Something about PR vs BFM?\\

% Skriv om plz...
All of the end-results were expected.
The table in the results section contains no surprises.
Brent's method got the same score as regular Pollard's rho given the same limit on the size of the numbers, but ran faster and could therefore try more, bigger, numbers, just as expected.


Given more time, we would have tried to implement the Quadratic Sieve.
We know that it is better than Pollard's rho algorithm, and it seemed to be the next logical step.


\newpage
\begin{thebibliography}{9}

\bibitem{pollard} \begin{flushleft} Pollard's rho algorithm - \url{http://en.wikipedia.org/wiki/Pollard's_rho_algorithm} <insert date here!> \end{flushleft}
\bibitem{birthday}Mosteller, Frederick. \emph{''Understanding the birthday problem.''} Selected Papers of Frederick Mosteller. Springer New York, p 349-353 (2006).
\bibitem{colorado} A Quick Tutorial on Pollard's Rho Algorithm - \url{http://www.cs.colorado.edu/~srirams/classes/doku.php/pollard_rho_tutorial}
\bibitem{brent} Brent, Richard P. \emph{''An improved Monte Carlo factorization algorithm.''} BIT Numerical Mathematics 20.2 (1980).
\bibitem{fermat} Fermat's factorization method - \url{http://en.wikipedia.org/wiki/Fermat's_factorization_method} <insert date here!>
\bibitem{qsieve} Quadratic sieve - \url{http://en.wikipedia.org/wiki/Quadratic_sieve} <insert date here!>
\bibitem{qsieve2} Pomerance, Carl. \emph{''Analysis and comparison of some integer factoring algorithms.''} Mathematisch Centrum Computational Methods in Number Theory, Pt. 1 p 89-139(SEE N 84-17990 08-67) (1982).
\bibitem{otherpaper} Barnes, Connelly. \emph{''Integer Factorization Algorithms.''} Oregon State University (2004).
\bibitem{gmp} GMP Homepage - \url{http://gmplib.org} <insert date here!>
\bibitem{probabprime} \begin{flushleft}GMP Number Theoretic Functions - \url{http://gmplib.org/manual/Number-Theoretic-Functions.html} <insert date here!>\end{flushleft}
\bibitem{algnotes} Notes for the course advanced algorithms - \url{http://www.nada.kth.se/~johanh/algnotes.pdf} <insert date here!>
\bibitem{csh} Pollard's Rho Method - \url{http://www.csh.rit.edu/~pat/math/quickies/rho/}

\end{thebibliography}

\end{document}
