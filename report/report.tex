%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt,numbers=endperiod]{scrartcl} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
%\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line today return to the LaTeX default
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages

\usepackage[utf8]{inputenc} % Needed to support swedish "åäö" chars
\usepackage{titling} % Used to re-style maketitle

\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\normalfont} % Make all sections the default font

% Local packages:
\usepackage{enumerate}
\usepackage[usenames,dvipsnames]{color}
\usepackage{tabularx}
\usepackage{fancyvrb}
\DefineShortVerb{\|}
\usepackage{hyperref}
\usepackage{url}
\usepackage[parfill]{parskip}   % Sets newlines between paragraphs
\usepackage{algorithm2e} % Used for Pseudocode
\providecommand{\abs}[1]{\lvert#1\rvert} % \abs{x+y} produces |x+y|



\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

% Header with additional info
% \fancyhead[L]{\small{Gustaf Lindstedt - \href{mailto:glindste@kth.se}{\color{RoyalBlue}\nolinkurl{glindste@kth.se}} - 910301\\Martin Runelöv - \href{mailto:mrunelov@kth.se}{\color{RoyalBlue}\nolinkurl{mrunelov@kth.se}} - 900330-5738}}
% Simple header
\fancyhead[L]{\small{Gustaf Lindstedt\\Martin Runelöv}} % 


\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{23.0pt} % Customize the height of the header
\fancyhfoffset[L]{10mm}% slightly less than 0.25in

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text


\posttitle{\par\end{center}} % Remove space between author and title
%----------------------------------------------------------------------------------------
% TITLE SECTION
%----------------------------------------------------------------------------------------

\title{ 
\huge Project 1 - Factoring \\ % The assignment title
\vspace{10pt}
\normalfont \normalsize 
\textsc{DD2440 - Advanced algorithms } \\ [25pt] % 
}

\author{Gustaf Lindstedt \\ glindste@kth.se \\ 910301-2135 \and Martin Runelöv \\ mrunelov@kth.se \\ 900330-5738}

\date{\vspace{8pt}\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

%-------------------------------------------------------------------------------
% SECTION 1
%-------------------------------------------------------------------------------

% Abstract?


\section{Introduction}

% heh orkade inte ha ett intro direkt med underrubrik.
This project was done as part of the course \emph{Advanced Algorithms} at the Royal Instityte of Technology, KTH.

\subsection{Problem}
A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.
The prime factorization of a positive integer is a list of primes that divides the integer, and their multiplicities.
The problem of finding these prime factors is called integer factorization.

The fundamental theorem of arithmetic states that every positive integer (> 1) is either prime or a unique product of prime numbers.
In other words, all natural numbers can be factorized.

The purpose of this project is to study and implement factorization algorithms in order to successfully factorize a set of composite numbers, most of which are non-trivial.



%-------------------------------------------------------------------------------
% SECTION 2
%-------------------------------------------------------------------------------
\section{Method}
\subsection{Algorithms}
\subsubsection{Pollard's rho algorithm}
Pollard's rho algorithm \cite{pollard}\cite{algnotes} is a probabilistic algorithm that tries to find one factor of a composite number.
The algorithm is run multiple times until the number is completely factorized, or until it fails.

The idea behind the algorithm is that we can improve the odds of guessing a factor of a composite number $N$.
The phenomenon is known as the \emph{birthday problem} or \emph{birthday paradox} \cite{birthday}.
The name comes from the following example: The probability of any two people sharing a birthday in a room of 23 people is 50\%, assuming all birthdays are equally probable.
For 57 people, the probability is 99\%. The probability only reaches 100\% for 367 people, but the often unexpected result is that the probability increases exponentially.

Suppose that we want to guess a factor $d$ of $N$.
We know that at least one factor is less than or equal to $\sqrt{N}$, so we can safely say that we have a $\frac{1}{\sqrt{N}}$ chance of guessing $d$.
% Annan pdf som går igenom sambandet mellan birthday och pollards:
% http://www.mpi-inf.mpg.de/~csaha/lectures/lec18.pdf 
If we instead pick two integers $x_i$ and $x_j$ in a random sequence ${x_1 .. x_k} \in [0,N]$ 
and check if their difference $\abs{x_i - x_j} = d$ we have increased our odds of guessing $d$, 
according to the observation made in the birthday problem. 
\cite{birthday2}
% ^ ett sätt att förenkla på. finns självklart massa varianter. 

This is exactly what Pollard's rho algorithm makes use of by using a pseudo-random generator to generate a sequence.
The pseudo-random sequence generator originally used by Pollard is $x^2 + 1 \bmod N$.
The reasons for using this specific function are that it is easy to implement, and works well in practice \cite{algnotes}.
There are, however, alternatives.
For example, Brent suggested that we use $x^2 +3 \bmod N$ with his modified Pollard's rho algorithm (see section below).
This was empirically motivated based on test results. \cite{brent}

In order to avoid keeping the entire sequence in memory, Floyd's cycle-finding algorithm (also known as the ''tortoise and the hare'' algorithm) is used to only keep two pointers to values in the sequence.
According to this algorithm, the only two values that we need to keep track of are the ones at index $i$ and $2i$. \cite{floyd}

Pollard's rho algorithm therefore repeatedly calculates two values $x_i$ and $x_2i$ from the sequence and calculates $gcd(\abs{x_{2i}-x_i})$.
% Här, eller innan, kan man förklara varför gcd funkar. dvs varför vi har hittat d. Finns nåt modulo-bevis.
If the result is greater than 1 (and not $N$ itself), the result is a non-trivial factor of $N$.
See the pseudocode for Pollard's rho algorithm below.

Note that the pseudocode does not take into account the case where $d = N$.
If $d = N$, the algorithm has failed to find a factor since this means that the sequence has cycled.

\begin{algorithm}[H]
 \SetAlgoLined % For previous releases [?]
 \textbf{Input:} {A composite number N}\\
 \textbf{Output:} {A non-trivial factor of N}\\
 let $x_0 \in_U \mathbb{Z}_N$\\ 
 $x := x_0$\;
 $y := x_0$\;
 \While{True}{
  $x := f(x)$\;
  $y := f(f(y))$\;
  $d := gcd( \abs{y-x}, N)$\;
  \If{$d > 1$}{
   return d\;
   }
 }
 \caption{Pollard's rho algorithm \cite{algnotes}}
\end{algorithm}
\hspace{0pt}\\\\


\subsubsection{Brent's Factorization Method}
% Förslag till ändring från nedanstående utkommenterade mening
Brent's method is built upon Pollard's rho algorithm.
It improves detection of periodicity in the pseudo-random sequence by replacing Floyd's cycle-finding algorithm with a similar algorithm called Brent's cycle-finding method. \cite{brent}

This improvement mostly centers around the fact that multiplying consecutive differences $\abs{x_{2i}-x_i}$ preserves any divisor $d$ of $N$.
Therefore the computation of a greatest common divisor, which is expensive, can be performed a lot less.
Brent suggests to multiply $m$ consecutive values where $\log{N} \ll m \ll N^{1/4}$.
However, large values of $m$ increase the probability of the product $q$ growing to $q = 0 \bmod N$, which is unwanted since we then get the result $d=N$.
Therefore Brent suggests not using too large $m$ values.
If the case where $q = 0 \bmod N$ is encountered, the situation can be resolved by backtracking to the last $x_i$ and $x_{2i}$ and performing the regular Pollard's rho procedure if $d=N$.
Although Pollard's algorithm sometimes also encounter this same problem, it does so much less likely.

A speedup of the algorithm is also suggested, which consists of omitting terms $\abs{x_r - x_k}$ in the product if $ k < \frac{3r}{2}$.
This is motivated by the fact that any factor contained in these terms are also contained in the terms where $\frac{3r}{2} \le k < 2r$.

Pseudocode for Brent's factorization method: \\

\begin{algorithm}[H]
 \SetAlgoLined % For previous releases [?]
 \textbf{Input:} {A composite number N}\\
 \textbf{Output:} {A non-trivial factor of N}\\
 $y := 2$\tcp*[l]{arbitrary start value}
 $r := 1$\;
 $q := 1$\;
 \Repeat{d > 1} {
   $x := y$\;
   \For{i := 1 to r}{
   $y := f(y)$\;
   }
   $k := 0$\;
   \Repeat{ $k \geq r$ or d > 1 }{
      $ys := y$\;
      \For(\tcp*[h]{accumulate differences}){i := 1 to min(m, r--k)}{
        $y := f(y)$\;
        $q := q\times\abs{x-y} \bmod N$
      }
      $d := gcd(q, N)$\;
      $k := k + m$\;
   }
   $r := r\times2$\;
 }
 \If(\tcp*[h]{try previous y}){G = N}{
    \Repeat{G > 1}{
      $ys := f(ys)$\;
      $d = gcd(\abs{x-ys},N)$\;
    }
 }
 \caption{Brent's factorization method \cite{brent}}
\end{algorithm}
\hspace{0pt}\\\\



\subsubsection{Fermat's Factorization Method}
Fermat's factorization method \cite{fermat} is based on the ability to represent an odd integer as the difference of two squares $N = a^2 - b^2$.
This also satisfies the weaker condition of a congruence of squares, where $a^2 \equiv b^2 \bmod N$ where $a \not\equiv \pm b \bmod N$, which is used in the Quadratic Sieve method.
The expression $a^2 - b^2$ is factorable as $(a+b)(a-b)$, which makes $(a+b)$ and $(a-b)$ factors of $N$.
Different values of $a$ are tried, searching for an $a$ such that the expression $a^2 - N$ yields a perfect square $b^2$.
The algorithm then returns $a - \sqrt{b^2} = a - b$, which is one of the factors.

\begin{algorithm}[H]
 \SetAlgoLined % For previous releases [?]
 \textbf{Input:} {A composite number N}\\
 \textbf{Output:} {A non-trivial factor of N}\\
 $a := ceil(sqrt(N))$\\
 $b2 := a*a - N$\\
 \While{b2 isn't a square}{
  $a := a+1$\;
  $b2 := a*a - N$\;
  }
  return $a-sqrt(b2)$\;
  \hspace{0pt}\\
  \caption{Fermat's factorization method \cite{fermat}}
\end{algorithm}

\subsubsection{Quadratic Sieve}
The quadratic sieve \cite{qsieve} is the fastest known factorization algorithm for numbers below about 100 decimal digits \cite{qsieve2}. 

% oklart om detta är noggrant nog. tänkte börja enkelt innan vi bestämmer oss för att gå djupt.
The quadratic sieve works similarly to Fermat's factorization method.
However it searches for a congruence of squares modulo $N$, which is a weaker condition than the one used by Fermat's method.
A congruence of squares $a^2 \equiv b^2 \bmod N$ is equivalent to $(a+b)(a-b) \equiv 0 \bmod N$.
This means that $(a+b)$ and $(a-b)$ each contain factors of $N$, which can be found by calculating the GCD of $(a+b)$ and $(a-b)$ of $N$ respectively.

Finding these congruences of squares however, is not trivial.
To find them the algorithm begins with a data gathering phase, where the expression $a^2 \bmod N$ is calculated for several values of $a$.
Care is taken to choose so called smooth numbers, i.e. numbers that consists of small primes, which is important for later steps.
The calculated values are then multiplied with each other, and a subset of these will produce squares.

% Det under måste skrivas om för att flyta ihop
To efficiently find the subset whose products are squares, the algorithm makes use of linear algebra in the form of exponent vectors.
An exponent vector is a vector of the form $(4, 2)$, where the elements signify the prime exponents for the $i$-th prime.
In this case the vector represents the number $2^4 3^2 = 144$.
The basic idea is to study the parity of each of the exponents in the exponent vector.
For example, the number $144$ is a square since its prime factorization is $2^{4}3^2$ and both exponents $4$ and $2$ are even ($144 = 2^2 3^1\times2^2 3^1$).

Since only the parity of the exponents needs to be considered, the vectors can store the exponents modulo 2.
Thus we are left with vectors of 1's and 0's, 1 if the exponent is odd and 0 if the exponent is even.
If we have two different numbers with corresponding vectors, the vector resulting from their multiplication is the same as performing an XOR operation on the two vectors.
A perfect square is achieved when this vector contains only 0's.

Thus the problem is now to find a subset of vectors which XOR to the zero vector from a set of exponent vectors modulo 2.
This can be calculated using Gaussian elimination, and the square is the product of the numbers which the vectors correspond to.
At this stage it is important that smooth numbers have been used in order to keep the exponent vectors small, thus reducing the size of the matrix.

% Övriga steg påminner om/är exakt som Fermat's?

\subsection{Implementation}
Both Fermat's Factorization Method and Pollard's Rho, along with Brent's improvements, were implemented.
The Quadratic Sieve method was not implemented due to time constraints.

The algorithms were written in |C| and the GMP \cite{gmp} library was used to represent large numbers and perform functions such as primality testing and GCD.

A static list of the first 10 000 primes was used to weed out trivial primes with trial division, since a composite number often contains low primes.
Depending on the algorithm and other parameters, we used varying amounts of these primes for trial division.

Before each call to the factorization algorithm, primality testing was perfomed to see if the number to be factored was already prime.
This was done using GMP's built-in function |mpz_probab_prime| which uses trial division and Miller-Rabin probabilistic primality tests internally\cite{probabprime}.

To achieve maximum performance, we had to limit the number of cycles and the size of the numbers we tried to factor.

\subsubsection{Fermat's Algorithm}
We did not encounter any notable issues implementing Fermat's algorithm, since it is relatively simple.
We found that doing trial division of the 9000 first primes before running Fermat's algorithm yielded the best results.
After the trial division, we only tried to factor integers of size less than 80 bits, and we limited the amount of iterations to 3 000 000.

\subsubsection{Pollard's Rho Algorithm}
When using Pollard's rho algorithm only the first 500-2000 primes were used for trial division.


After implementing Pollard's rho algorithm we improved it by converting it to Brent's factorization method.

Both algorithms were given a limit on the number of |gcd| calculations to make. % Both som i Fermat och Pollard? eller som i vanilla pollard + brent?


%Massa om hur vi implementerade koden

%-------------------------------------------------------------------------------
%   SECTION 3
%-------------------------------------------------------------------------------

\section{Results}

The table below shows you how many of the 100 KATTIS numbers that the different algorithms were able to factorize.

    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Algorithm} & \textbf{Factorized numbers} \\ \hline
    Trial division & 11 \\ \hline
    Trial division + primality test & 19 \\ \hline
    Fermat's & 29 \\ \hline
    Pollard's rho & 73 \\ \hline
    Brent's & 87* \\ \hline
    \end{tabular}
    \hspace{10pt}

    \footnotesize{*submission ID for the best submission: \href{https://kth.kattis.scrool.se/submission?id=457076}{457076}
    \normalsize

Note that the three factorization algorithms Fermat's, Pollard's and Brent's all use trial division and primality testing.

Pollard's rho algorithm got results between 57 and 73, and Brent's factorization method got results between 73 and 86.
In order to avoid going over the time limit of 15 seconds we had to skip numbers above a certain size.
Pollard's rho got its best results when we only tried to factorize numbers smaller than 86 bits.
Since Brent's method is faster, we were able to include numbers up to 95 bits without reaching the time limit.

We also had to set a limit on the number of iterations that the algorithms made.
This was done using trial-and-error since the number of iterations necessary depends on the numbers to be factored.
These iteration limits turned out to be slightly arbitrary once above a certain threshold, which seems to indicate that most if not all numbers were successfully factored.
However, one slight modification was made in Brent's method.
The number of iterations performed for numbers greater than 90 bits in size were set a lot lower than the default limit.
This was necessary in order to finish on time.
This can be explained by the fact that we fail to factorize many of these bigger numbers, 
and even if we succeed they could require many iterations.

After reaching 86 points we noted that the backtrack loop used by Brent's method, when the first loop results in $d = N,$ never found any factors.
With this loop removed we achieved the same result slightly faster.

We also experimented with the |m| and |C| variables (C being the constant in the pseudo-random generator).
In general, setting |C| to 3 instead of 1, as suggested by Brent, lead to a significant increase in runtime.
However, this was probably due to poor interaction with other variables.

According to Brent, the value of |m| should often be low, and in general $log(N) << m << N^{1/4}$.
We tried making |m| dependent on the number of bits in N, since the number of bits is $log_2(N)$, but we got better results with |m| set to fixed values between 60 and 100.

% Something about default iterations maxing out at 30k instead of about 100k for most numbers?
% And maybe mention starting values, "m", "C" etc? C = 1 even for Brent. TLE for 3.


\subsection{Discussion}
%Were the results expected? Why?\\
%Given more time, what could have been improved?\\
%Something about PR vs BFM?\\

% Skriv om plz...
All of the end-results were expected.
Compared to each other the algorithms performed as expected (see results table).
Brent's method got the same score as regular Pollard's rho given the same limit on the size of the numbers, but ran faster and could therefore try more, bigger, numbers, just as expected.

Given more time, we would have tried to implement the Quadratic Sieve.
We know that it is better than Pollard's rho algorithm, and it seemed to be the next logical step.
However, after reading up how to implement it we came to the conclusion that it would probably be hard to implement in such a short period of time.

The fact that some theory was not applicable could have been due to bad luck with the problem set. For example, setting a dynamic |m| never improved our results, but in theory it could have.


\newpage
\begin{thebibliography}{9}

\bibitem{pollard} \begin{flushleft} Pollard's rho algorithm - \url{http://en.wikipedia.org/wiki/Pollard's_rho_algorithm} <insert date here!> \end{flushleft}
\bibitem{algnotes} Notes for the course advanced algorithms - \url{http://www.nada.kth.se/~johanh/algnotes.pdf} <insert date here!>
\bibitem{birthday}Mosteller, Frederick. \emph{''Understanding the birthday problem.''} Selected Papers of Frederick Mosteller. Springer New York, p 349-353 (2006).
\bibitem{birthday2} Computational Number Theory and Algebra - Lecture - \url{http://www.mpi-inf.mpg.de/~csaha/lectures/lec18.pdf}
\bibitem{colorado} A Quick Tutorial on Pollard's Rho Algorithm - \url{http://www.cs.colorado.edu/~srirams/classes/doku.php/pollard_rho_tutorial}
\bibitem{floyd} \begin{flushleft}Floyd's cycle-finding algorithm - \url{http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare} \end{flushleft}
\bibitem{brent} Brent, Richard P. \emph{''An improved Monte Carlo factorization algorithm.''} BIT Numerical Mathematics 20.2 (1980).
\bibitem{fermat} Fermat's factorization method - \url{http://en.wikipedia.org/wiki/Fermat's_factorization_method} <insert date here!>
\bibitem{qsieve} Quadratic sieve - \url{http://en.wikipedia.org/wiki/Quadratic_sieve} <insert date here!>
\bibitem{qsieve2} Pomerance, Carl. \emph{''Analysis and comparison of some integer factoring algorithms.''} Mathematisch Centrum Computational Methods in Number Theory, Pt. 1 p 89-139(SEE N 84-17990 08-67) (1982).
\bibitem{otherpaper} Barnes, Connelly. \emph{''Integer Factorization Algorithms.''} Oregon State University (2004).
\bibitem{gmp} GMP Homepage - \url{http://gmplib.org} <insert date here!>
\bibitem{probabprime} \begin{flushleft}GMP Number Theoretic Functions - \url{http://gmplib.org/manual/Number-Theoretic-Functions.html} <insert date here!>\end{flushleft}
\bibitem{csh} Pollard's Rho Method - \url{http://www.csh.rit.edu/~pat/math/quickies/rho/}

\end{thebibliography}

\end{document}
